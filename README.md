# _kite_: kallisto indexing and tag extraction

This package offers a few utilities that enable fast and accurate pre-processing of Feature Barcoding experiments, a common datatype in single-cell genomics. In Feature Barcoding assays, cellular data are recorded as short DNA sequences using procedures adapted from single-cell RNA-seq. 

The __kite ("kallisto indexing and tag extraction__") package is used to prepare input files for Feature Barcoding experiments prior to running the kallisto | bustools scRNA-seq pipeline. Starting with a Python dictionary of Feature Barcode names and Feature Barcode sequences, the function `kite_mismatch_maps` produces a "mismatch map" and outputs "mismatch" fasta and transcript-to-gene (t2g) files. The mismatch files, containing the Feature Barcode sequences and their Hamming distance = 1 mismatches, are required for kallisto | bus. 

The mismatch fasta file is used by `kallisto index` with a k-mer length -k equal to the length of the Feature Barcode. 

After running `bustools correct` and `bustools count`, the t2g file is used by bustools count to generate a Features x Cells matrix. In this way, kallisto | bustools will effectively search the sequencing data for the Feature Barcodes and their Hamming distance = 1 neighbors. We find that for Feature Barcodes of moderate length (6-15bp) pre-processing is remarkably fast and the results equivalent to or better than those from traditional alignment.

The Vignettes directory [https://github.com/pachterlab/kite/tree/master/docs/Vignettes] contains Python notebooks with complete examples for 10X and CITE-seq data. They show how to use kite, kallisto | bustools, and ScanPy to perform a complete feature barcoding analysis, and the results are compared with CellRanger. 

NOTE: To avoid potential pseudoalignment errors arising from inverted repeats, kallisto requires odd values for the k-mer length k.If your Feature Barcodes have an even length, just add a constant base one side and follow the protocol as suggested. 

## kite Utilities

#### `kite_mismatch_maps(dict, mismatch_t2g_path, mismatch_fasta_path`
This wrapper function is the easiest way to use `kite`. Just input a Python dictionary, and `kite_mismatch_map` will output a "mismatch" t2g file and a "mismatch" fasta file. These files are used by kallisto | bustools to complete pre-processing(see above and Vignettes).

#### `make_mismatch_map(filename)`

This function returns all sample tags and and their single base mismatches (hamming distance 1) as an OrderedDict object. The size of the object is (k=the length of the Feature Barocdes)*(3=altnerative base pairs for each base)*(N=number of Feature Barocdes) + (N=number of Feature Barcode sequences). For the 10x example dataset, 17 Feature Barcodes of length k=15 are used. These yield 15*3*17+17=782


#### `write_mismatch_map(tag_map, tagmap_t2g_path, tagmap_fasta_path)`

Saves the OrderedDict generated by `make_mismatch_map` (tag_map) to file in fasta and t2g formats for building the kallisto index and running bustools count, respectively.



## Example: 1k PBMCs from a Healthy Donor - Gene Expression and Cell Surface Protein

The notebook [kite_citeseq_SRR8281307](https://github.com/pachterlab/kite/blob/master/docs/kite_citeseq_SRR8281307.ipynb) in the `docs` folder demonstrates a complete analysis for a 10x dataset collected on 730 peripheral blood mononuclear cells (PBMCs) labeled with 17 unique Feature Barcoded antibodies. 

The following is an abbreviated walk-through.  

We start with a Python dictionary containing Feature Barcode names and Feature Barcode sequences. 
```
feature_barcodes={'CD3_TotalSeqB': 'AACAAGACCCTTGAG',
 'CD4_TotalSeqB': 'TACCCGTAATAGCGT',
 'CD8a_TotalSeqB': 'ATTGGCACTCAGATG',
 'CD14_TotalSeqB': 'GAAAGTCAAAGCACT',
 'CD15_TotalSeqB': 'ACGAATCAATCTGTG',
 'CD16_TotalSeqB': 'GTCTTTGTCAGTGCA',
 'CD56_TotalSeqB': 'GTTGTCCGACAATAC',
 'CD19_TotalSeqB': 'TCAACGCTTGGCTAG',
 'CD25_TotalSeqB': 'GTGCATTCAACAGTA',
 'CD45RA_TotalSeqB': 'GATGAGAACAGGTTT',
 'CD45RO_TotalSeqB': 'TGCATGTCATCGGTG',
 'PD-1_TotalSeqB': 'AAGTCGTGAGGCATG',
 'TIGIT_TotalSeqB': 'TGAAGGCTCATTTGT',
 'CD127_TotalSeqB': 'ACATTGACGCAACTA',
 'IgG2a_control_TotalSeqB': 'CTCTATTCAGACCAG',
 'IgG1_control_TotalSeqB': 'ACTCACTGGAGTCTC',
 'IgG2b_control_TotalSeqB': 'ATCACATCGTTGCCA'}
```
The kite_mismatch_maps function takes a Python dictionary (featurebarcodes) and writes a mismatch t2g and mismatch fasta. In this way, the 17 original Feature Barcodes become a mismatch fasta file and a mismatch t2g file, each with 782 entries.

```
import kite
kite.kITE_mismatch_maps(featurebarcodes, './t2g_path.t2g', 'fasta_path.fa')
```

Feature Barcode processing is similar to processing transcripts except instead of looking for transcript fragments of length `k` (the `k-mer` length) in the reads, using a "mismatch" index will search the raw reads using the Feature Barcode whitelist and the Hamming Distance = 1 mismatches. Please refer to the kallisto documentation for more information on the kallisto | bustools workflow. 

Because Feature Barcodes are typically designed to be robust to some sequencing errors, each Feature Barcode and its mismatches are unique across an experiment, thus each Feature Barcode equivalence class has a one-to-one correspondence to a member of the Feature Barcode whitelist. This is reflected in the t2g file, where each mismatch Feature Barcode points to a unique parent Feature Barcode from the whitelist, analogous to the relationship between genes and transcripts in the case of cDNA processing. 

The mismatch fasta is used to run `kallisto index`, and `kallisto inspect` can be used to view index information. 

`!kallisto index -i {index_path}.idx -k 15 {fasta_path}`

Next, `kallisto bus` and `bustools` are used without modifications. 

```
kallisto bus -i {index_path}.idx -o {write_folder} -x 10xv3 -t 4 \
'.pbmc_1k_protein_v3_antibody_S2_L001_R1_001.fastq.gz' \
'.pbmc_1k_protein_v3_antibody_S2_L001_R2_001.fastq.gz' \
'.pbmc_1k_protein_v3_antibody_S2_L002_R1_001.fastq.gz' \
'.pbmc_1k_protein_v3_antibody_S2_L002_R2_001.fastq.gz' \
```

We now have a BUS file for this pseudoalignment. 
```
!bustools correct -w ./10xwhitelist/CRwhitelist/3M-february-2018.txt './output.bus' -o ./output_corrected.bus'

!bustools sort -t 4 -o './output_sorted.bus' './output_corrected.bus'

!bustools count -o ./ --genecounts -g './t2g_path.t2g' -e './matrix.ec' -t './transcripts.txt' './output_sorted.bus'

```

From here, standard analysis packages like ScanPy and Seurat can be used to continue the Feature Barcode analysis. 
